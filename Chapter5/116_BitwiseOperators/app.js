/*          Bitwise Operators            */
/*           簡單測試 & | ^             */
// 注意 2的補數 32bit 的第一開頭正數為0 負數為1
let a = 7; //0...0111
let b = 11; //0...1011

console.log(a & b); //0011 =3
console.log(a | b); //1111 =15
console.log(a ^ b); //1100 =12

console.log("---   ~ a   ---");
console.log(~a); //不是8 其實是-8 這個要去了解 2's complement
// 原始有32位元 每個都要反轉，所以是1111.....1000 這才是我們的數字

// -------- 2's complement 可得知負數1111.....1000 所代表數字為何 -------
// 簡單說就是 bit 取反轉 然後最低位bit代表2^0的那位 +1  可得知對應的數是誰。
// 1111....1000 做2's complement 先反轉
// 0000....0111 +1
// 0000....1000 = 8   因為原本數字 1開頭 ，代表負數 => 實為 -8
// 8 如何轉成 -8   一樣的事情照做 先反轉位元
// 1111....0111 +1  得到下面
// 1111....1000  就是 -8的表示值

/*           <<   >>                  */
let x = 16;
let y = 8;
console.log("------- << ------");
console.log("x<<2: " + (x << 2)); //*4= 64
console.log("x<<3: " + (x << 3)); //*8= 128
console.log("y<<3: " + (y << 2)); //*4= 32
console.log("y<<3: " + (y << 3)); //*8= 64
console.log("------- >> ------");
console.log("x>>2: " + (x >> 2)); //div4= 4
console.log("x>>3: " + (x >> 3)); //div8= 2
console.log("y>>3: " + (y >> 2)); //div4= 2
console.log("y>>3: " + (y >> 3)); //div8= 1
